<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Основные сведения о типах курсоров</title><meta name="Language" content="ru-RU" /><meta name="System.Keywords" content="типы курсоров" /><meta name="Microsoft.Help.Id" content="4f4d3db7-4f76-450d-ab63-141237a4f034" /><meta name="Description" content="Операции в реляционной базе данных выполняются над множеством строк. Набор строк, возвращаемый инструкцией SELECT, содержит все строки, которые удовлетворяют условиям, указанным в предложении WHERE инструкции." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Основные сведения о типах курсоров</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Операции в реляционной базе данных выполняются над множеством строк. Набор строк, возвращаемый инструкцией SELECT, содержит все строки, которые удовлетворяют условиям, указанным в предложении WHERE инструкции. Такой полный набор строк, возвращаемых инструкцией, называется результирующим набором. Приложения не всегда могут эффективно работать с результирующим набором, представляющим единое целое. Им нужен механизм, позволяющий обрабатывать одну строку или небольшое их число за один раз. Курсоры являются расширением результирующих наборов, которые предоставляют такой механизм. </p><p>Курсоры расширяют возможности обработки результирующего набора, выполняя следующие функции:</p><ul><li><p>позиционируясь на отдельные строки результирующего набора;</p></li><li><p>получая одну или несколько строк от текущей позиции в результирующем наборе;</p></li><li><p>поддерживая изменение данных в строке, находящейся в текущей позиции в результирующем наборе;</p></li><li><p>поддерживая разные уровни видимости изменений, сделанных другими пользователями для данных, представленных в результирующем наборе.</p></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Полное описание типов курсоров SQL Server см. в разделе «Типы курсоров (компонент Database Engine)» электронной документации по SQL Server.</p></div><p>Спецификация JDBC обеспечивает поддержку однопроходных курсоров и прокручиваемых курсоров, которые могут учитывать или не учитывать изменения, выполненные другими заданиями, а также быть доступными только для чтения или допускать обновление. Эта функциональность обеспечивается классом <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> драйвера Драйвер Microsoft JDBC для SQL Server.</p></div><h1 class="heading">Примечания</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Драйвер JDBC поддерживает следующие типы курсоров.</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Тип (курсора) </p><p>результирующего набора</p></th><th><p>Тип курсора SQL Server</p></th><th><p>Характеристики</p></th><th><p>Метод</p><p>выбора</p></th><th><p>Буферизация</p><p>ответов</p></th><th><p>Описание</p></th></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Н/Д</p></td><td><p>Однонаправленный, только для чтения</p></td><td><p>Прямой</p></td><td><p>Полная</p></td><td><p>Приложение выполняет один (однонаправленный) проход по результирующему набору. Этот режим активен по умолчанию и действует аналогично курсору TYPE_SS_DIRECT_FORWARD_ONLY. Драйвер считывает весь результирующий набор с сервера в память во время выполнения инструкции. </p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Н/Д</p></td><td><p>Однонаправленный, только для чтения</p></td><td><p>Прямой</p></td><td><p>Адаптивная</p></td><td><p>Приложение выполняет один (однонаправленный) проход по результирующему набору. Работает аналогично курсору TYPE_SS_DIRECT_FORWARD_ONLY. Драйвер считывает строки с сервера по мере того как приложение запрашивает строки. Это позволяет снизить загрузку памяти на стороне клиента.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Быстрый однопроходный</p></td><td><p>Однонаправленный, только для чтения</p></td><td><p>Курсор</p></td><td><p>Н/Д</p></td><td><p>Приложение должно выполнить один (однонаправленный) проход по результирующему набору, используя серверный курсор. Работает аналогично курсору TYPE_SS_SERVER_CURSOR_FORWARD_ONLY.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)</p></td><td><p>Динамический (однопроходный)</p></td><td><p>Однопроходный, обновляемый</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Приложение должно выполнить один (однонаправленный) проход по результирующему набору, чтобы обновить одну или несколько строк. </p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p><p>По умолчанию размер выборки фиксируется, когда приложение вызывает метод <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> объекта <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Драйвер JDBC предоставляет функцию адаптивной буферизации, которая позволяет получать результаты выполнения инструкций от SQL Server по запросу приложения, а не все сразу. Например, если приложение должно получить данные, которые не могут полностью разместиться в памяти приложения, адаптивная буферизация позволяет клиентскому приложению получать значения в виде потока. </p><p>По умолчанию в драйвере применяется режим <span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span>. Однако, чтобы включить адаптивную буферизацию для однопроходных обновляемых результирующих наборов, приложение должно явно вызвать метод <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> объекта <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a>, предоставив значение типа <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> (<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>). Образец кода см. в разделе <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Образец обновления данных большого объема</a></span>.</p></div></td></tr><tr><td><p>TYPE_SCROLL_INSENSITIVE</p></td><td><p>Статичный</p></td><td><p>Прокручиваемый, без поддержки обновления.</p><p>Внешние операции обновления, вставки и удаления строк не видимы.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Приложению требуется моментальный снимок базы данных. Результирующий набор не поддерживает обновление. Поддерживается только CONCUR_READ_ONLY.  Все остальные типы параллелизмы в случае использования с этим типом курсора вызывают исключение.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Набор ключей</p></td><td><p>Прокручиваемый, только для чтения. Внешние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные.</p><p>Внешние операции вставки невидимы. </p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Приложению должны быть видимы только измененные данные для существующих строк.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Набор ключей</p></td><td><p>Прокручиваемый, обновляемый. </p><p>Внешние и внутренние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные; операции вставки невидимы.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Приложение может изменять данные в существующих строках с помощью объекта <b>ResultSet</b>. Приложению также должны быть видимы изменения в строках, выполненные другими пользователями вне объекта <b>ResultSet</b>.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SS_DIRECT_FORWARD_ONLY</p></td><td><p>Н/Д</p></td><td><p>Однонаправленный, только для чтения</p></td><td><p>Н/Д</p></td><td><p>Полная или адаптивная</p></td><td><p>Целое значение = 2003. Предоставляет клиентский курсор, доступный только для чтения, с полной буферизацией. Серверный курсор не создается.</p><p>Поддерживается только тип параллелизма CONCUR_READ_ONLY. Все остальные типы параллелизмы в случае использования с этим типом курсора вызывают исключение.</p></td></tr><tr><td><p>TYPE_SS_SERVER_CURSOR_FORWARD_ONLY</p></td><td><p>Быстрый однопроходный</p></td><td><p>Однонаправленный</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целое значение = 2004. Быстрый режим, доступ ко всем данным выполняется с помощью серверного курсора. В случае использования с типом параллелизма CONCUR_UPDATABLE возможно обновление.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p><p>Чтобы включить адаптивную буферизацию в этом случае, приложение должно явно вызвать метод <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> объекта <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a>, указав значение типа <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> (<span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span>). Образец кода см. в разделе <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Образец обновления данных большого объема</a></span>.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_STATIC</p></td><td><p>Статичный</p></td><td><p>Не отражает обновления, выполненные другими пользователями.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целочисленное значение = 1004. Приложению требуется моментальный снимок базы данных. Это синоним SQL Server для типа JDBC TYPE_SCROLL_INSENSITIVE, который имеет те же параметры параллелизма по умолчанию.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Набор ключей</p></td><td><p>Прокручиваемый, только для чтения. Внешние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные.</p><p>Внешние операции вставки невидимы.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целое значение = 1005. Приложению должны быть видимы только измененные данные для существующих строк. Это синоним SQL Server для типа JDBC TYPE_SCROLL_SENSITIVE, который имеет те же параметры параллелизма по умолчанию.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Набор ключей</p></td><td><p>Прокручиваемый, обновляемый. </p><p>Внешние и внутренние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные; операции вставки невидимы.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целое значение = 1005. Приложение должно изменять данные, или для него должны быть видимыми измененные данные для существующих строк. Это синоним SQL Server для типа JDBC TYPE_SCROLL_SENSITIVE, который имеет те же параметры параллелизма по умолчанию.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Динамический</p></td><td><p>Прокручиваемый, только для чтения. </p><p>Внешние операции обновления и вставки строк являются видимыми, а операции удаления представляются как временно отсутствующие данные в текущем буфере выборки. </p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целое значение = 1006. Приложению должны быть видимы измененные данные для существующих строк, а также вставленные и обновленные строки за время существования курсора.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Динамический</p></td><td><p>Прокручиваемый, обновляемый. </p><p>Внешние и внутренние операции обновления и вставки строк являются видимыми, а операции удаления представляются как временно отсутствующие данные в текущем буфере выборки.</p></td><td><p>Н/Д</p></td><td><p>Н/Д</p></td><td><p>Целое значение = 1006. Приложение может изменять данные для существующих строк, а также вставлять и удалять строки с помощью объекта <b>ResultSet</b>. Приложению также должны быть видимы изменения в строках, операции вставки и удаления, выполненные другими пользователями вне объекта <b>ResultSet</b>.</p><p>Строки извлекаются с сервера блоками, размер которых определяется размером выборки.</p></td></tr></table></div></div><h1 class="heading">Позиционирование курсоров</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Курсоры TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY и TYPE_SS_SERVER_CURSOR_FORWARD_ONLY поддерживают только метод позиционирования <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a>.</p><p>Курсор TYPE_SS_SCROLL_DYNAMIC не поддерживает методы <a href="638e8148-8ca0-4e1f-9ec2-04a11bc9809b.htm">absolute</a> и <a href="a266e3bc-05c2-44e2-9346-125ae6780216.htm">getRow</a>. Действие метода <b>absolute</b> можно приблизительно заменить сочетанием вызова методов <a href="67ed9447-7b10-4c87-98e7-f4c2e2470b3a.htm">first</a> и <a href="2bcdbb69-95fd-4ae8-8488-1a75a91fe2e0.htm">relative</a> для динамических курсоров.</p><p>Метод <b>getRow</b> поддерживается только курсорами TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET и TYPE_SS_SCROLL_STATIC. Метод <b>getRow</b> для всех типов однопроходных курсоров возвращает количество строк, считанных в курсоре на данный момент.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Если приложение выполняет неподдерживаемый вызов позиционирования курсора или неподдерживаемый вызов метода <b>getRow</b>, создается исключение с сообщением «Запрошенная операция не поддерживается с этим типом курсора».</p></div><p>Доступ к удаленным строкам предоставляется только курсорами TYPE_SS_SCROLL_KEYSET и эквивалентными курсорами TYPE_SCROLL_SENSITIVE. Если курсор позиционируется в удаленной строке, то значения столбцов недоступны, а метод <a href="9c6db315-e614-4604-b020-41af6a214cc1.htm">rowDeleted</a> возвращает значение true. Вызовы метода <b>get&lt;Type&gt;</b> приводят к созданию исключения с сообщением «Не удается получить значение из удаленной строки». Удаленные строки нельзя обновлять. Если вызвать метод <b>update&lt;Type&gt;</b> для удаленной строки, создается исключение с сообщением «Не удается обновить удаленную строку». Курсор TYPE_SS_SCROLL_DYNAMIC работает аналогичным образом, пока не выходит за пределы текущего буфера выборки.</p><p>Однопроходные и динамические курсоры предоставляют доступ к удаленным строкам аналогичным образом, но только при условии, что курсоры остаются доступными в буфере выборки. Для однопроходных курсоров это реализуется довольно очевидным образом. Для динамических курсоров ситуация усложняется в случае, когда размер выборки превышает 1. Приложение может перемещать курсор в обоих направлениях в пределах окна, заданного буфером выборки, однако удаленная строка будет исчезать, когда курсор будет покидать исходный буфер выборки, в котором была обновлена строка. Если временно удаленные строки не должны отображаться приложению, использующему динамические курсоры, следует использовать относительную выборку (0).</p><p>Если значения ключа для строки курсора TYPE_SS_SCROLL_KEYSET или TYPE_SCROLL_SENSITIVE обновляются с помощью курсора, то строка сохраняет исходную позицию в результирующем наборе независимо от того, отвечает ли обновленная строка условиям выборки курсора. Если строка обновляется вне курсора, то удаленная строка будет выводиться в исходной позиции строки, однако будет видна в курсоре только в случае, если в курсоре ранее присутствовала другая строка с новыми значениями ключа, однако затем была удалена. </p><p>Для динамических курсоров обновленные строки будут сохранять свои позиции в буфере выборки, пока курсор не покинет окно, определенное буфером выборки. Обновленные строки могут вновь появляться в других позициях в результирующем наборе или полностью исчезать. Приложения, которые должны избегать временной потери согласованности в результирующем наборе, должны использовать размер выборки 1 (по умолчанию используется 8 строк для параллелизма CONCUR_SS_SCROLL_LOCKS и 128 строк для остальных режимов параллелизма).</p></div><h1 class="heading">Преобразование курсоров</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Иногда SQL Server выбирает реализацию типа курсора, который отличается от запрошенного. Это называется неявным преобразованием курсора (или «деградацией курсора»). Дополнительные сведения о неявном преобразовании курсора см. в разделе «Использование неявных преобразований курсора» электронной документации по SQL Server.</p><p>В SQL Server 2000 во время обновления данных в результирующем наборе <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> и <b>ResultSet.CONCUR_UPDATABLE</b> создается исключение с сообщением «Этот курсор имеет тип READ ONLY». Это исключение создается, поскольку SQL Server 2000 выполнил неявное преобразование курсора для этого результирующего набора и не возвратил запрошенный обновляемый курсор.</p><p>Для этой проблемы существует два возможных решения.</p><ul><li><p>Убедитесь, что базовая таблица содержит первичный ключ.</p></li><li><p>Используйте <a href="d87afd89-3e75-402c-b844-1b434eb258df.htm">SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC</a> вместо <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> для создания инструкции.</p></li></ul></div><h1 class="heading">Обновление курсоров</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Обновления на месте поддерживаются для курсоров, если тип курсора и тип параллелизма поддерживают обновления. Если курсор не располагается в обновляемой строке в результирующем наборе (метод <b>get&lt;Type&gt;</b> не завершился успешно), то вызов метода <b>update&lt;Type&gt;</b> приведет к созданию исключения с сообщением «Результирующий набор не содержит текущую строку». В спецификации JDBC утверждается, что если метод обновления вызывается для столбца курсора, имеющего тип CONCUR_READ_ONLY, то создается исключение. В ситуациях, когда строка не доступна для обновления, например из-за конфликта оптимистичного параллелизма в случае конкурирующих операций обновления или удаления, исключение может не создаваться до вызова метода <a href="363d1008-1396-4fc0-8e27-c9ba2499e7f1.htm">insertRow</a>, <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> или <a href="aa04a644-c7c2-4738-8b6e-7fea566d2c16.htm">deleteRow</a>.</p><p>После вызова <b>update&lt;Type&gt;</b> доступ к столбцу будет невозможен с помощью <b>get&lt;Type&gt;</b> до вызова метода <b>updateRow</b> или <a href="2ecacca4-f7bc-4f5d-886a-da7747fdccae.htm">cancelRowUpdates</a>. Это позволяет избежать проблем, когда столбец обновляется с использованием типа, который отличается от типа, возвращенного сервером, а последующие вызовы метода считывания могут привести к преобразованиям типа на клиентской стороне, которые дают неточные результаты. Вызовы <b>get&lt;Type&gt;</b> создают исключение с сообщением «Доступ к обновляемым столбцам невозможен до вызова метода updateRow() или cancelRowUpdates()».</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Если метод <b>updateRow</b> вызван, когда столбцы не обновлены, драйвер JDBC вызывает исключение с сообщением «Метод updateRow() вызван, когда столбцы не обновлены».</p></div><p>После вызова метода <a href="f3c54bfe-d5b7-4f6e-ae6c-3e8954e5b1c9.htm">moveToInsertRow</a> исключение будет создаваться в случае вызова для результирующего набора любого метода, кроме методов позиционирования курсора <b>get&lt;Type&gt;</b>, <b>update&lt;Type&gt;</b>, <b>insertRow,</b> и (включая <a href="9a7c754c-2d72-4207-b3bd-2afc6047fb3d.htm">moveToCurrentRow</a>). Метод <b>moveToInsertRow</b> фактически переводит результирующий набор в режим вставки, а методы позиционирования курсора отменяют режим вставки. Вызовы относительного позиционирования курсора перемещают курсор относительно позиции, в которой он находился перед вызовом <b>moveToInsertRow</b>. После вызова позиционирования курсора ожидаемая позиция назначения становится новой позицией курсора.</p><p>Если вызов позиционирования курсора, выполненный в режиме вставки, не завершается успешно, то позицией курсора после ошибки вызова будет исходная позиция курсора до вызова метода <b>moveToInsetRow</b>. Если метод <b>insertRow</b> завершается ошибкой, то курсор остается в строке вставки в режиме вставки.</p><p>Столбцы в строке вставке первоначально находятся в неинициализированном состоянии. Вызовы метода <b>update&lt;Type&gt;</b> устанавливают инициализированное состояние столбца. Вызов метода <b>get&lt;Type&gt;</b> для неинициализированного столбца приводит к созданию исключения. Вызов метода <b>insertRow</b> возвращает все столбцы в строке вставки в неинициализированное состояние.</p><p>Если в момент вызова метода <b>insertRow</b> какие-либо столбцы не инициализированы, то вставляется значение по умолчанию для столбца. Если значение по умолчанию отсутствует, но столбец допускает значение NULL, то вставляется значение NULL. Если отсутствует значение по умолчанию, и столбец не допускает значения NULL, то сервер возвращает ошибку, и создается исключение.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p /><p>Вызовы метода <b>getRow</b> в режиме вставки возвращают значение 0. </p><p>Драйвер JDBC не поддерживает позиционированные операции обновления и удаления. В соответствии со спецификацией JDBC метод <a href="3f3ec4f2-103a-4e16-9206-c5bd8639f946.htm">setCursorName</a> не имеет эффекта, и в случае вызова метода <a href="e5b3af67-423a-4551-a4c6-a4bc076bd504.htm">getCursorName</a> создается исключение. </p><p>Статические курсоры и курсоры, доступные только для чтения, никогда не поддерживают обновление. </p><p>SQL Server ограничивает использование серверных курсоров единственным результирующим набором. Если пакет или хранимая процедура содержит несколько инструкций, то необходимо использовать клиентский однопроходный курсор, доступный только для чтения.</p></div></div><span id="seeAlsoSpan"><h1 class="heading">См. также</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="9ed5ad41-22e0-4e4a-8a79-10512db60d50.htm">Управление результирующими наборами с помощью драйвера JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Отправить <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dСпасибо%20за%20отзыв!%20Отзывы%20помогают%20команде%20разработчиков%20в%20улучшении%20документации.%20Просматривая%20ваши%20отзывы,%20корпорация%20Майкрософт%20может%20спросить%20по%20электронной%20почте%20ваше%20мнение,%20касающееся%20определенного%20решения.%20Адрес%20электронной%20почты%20не%20используется%20в%20других%20целях%20и%20удаляется%20корпорацией%20Майкрософт%20после%20завершения%20просмотра.%0\AДополнительные%20сведения%20о%20политике%20конфиденциальности%20корпорации%20Майкрософт%20см.%20на%20странице%20http://privacy.microsoft.com/ru-ru/default.aspx.%0\A%0\d','Отзывы%20пользователей.');">отзыв</a> об этом разделе в Майкрософт.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© © Корпорация Майкрософт (Microsoft Corporation), 2012 г. Все права защищены.</a></p></span></div></div></body></html>